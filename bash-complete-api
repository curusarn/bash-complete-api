#!/usr/bin/env bash

print_help() {
    echo "USAGE: bash-complete-api [OPTIONS] COMPLETION_FUNCTION COMP_CWORD COMP_POINT COMP_LINE [COMP_TYPE] [COMP_KEY]" >&2
    echo "In human language: function_to_call number_of_words cursor_position current_commandline_contents [type_of_completion] [key_that_triggered_completion]" >&2
    echo " " >&2
    echo "OPTIONS: -h|--help                    Shows this help" >&2
    echo "         -w|--wordbreaks CHARS        Sets wordbreaks to CHARS" >&2
    echo "         -S|--no-system-completion    Do not source system completion file" >&2
    echo "         -s|--source FILE             Sources FILE after sourcing system completion file" >&2
    echo "         -F|--deduce-function         Deduces completion function therefore it does not have to be specified as an argument" >&2
    echo "         -d|--debug LOGFILE           Log to LOGFILE" >&2
    echo "         --                           Ends option processing" >&2
}

print_completions() {
    printf '%s\n' "${COMPREPLY[@]}"
}

parse_complete_p() {
    # requires $complete_p
    # sets $comp_func OR $comp_cmd
    # sets $comp_o_opts 
    IFS=" " complete_p_arr=($complete_p)
    i=1
    comp_o_opts=""
    while [ $i -lt ${#complete_p_arr} ]; do
        case ${complete_p_arr[i]} in
            -F)
                comp_func=${complete_p_arr[i+1]}
                ((i++))
                ;;
            -C)
                comp_cmd=${complete_p_arr[i+1]}
                ((i++))
                ;;
            -o)
                comp_o_opts="$comp_o_opts -o ${complete_p_arr[i+1]}"
                ((i++))
                ;;
            *)
                ;;
        esac
        ((i++))
    done
}

do_complete() {
    # designed to be called after parse_complete_p()

    if [ "$comp_func" != "" ]; then
        # echo "Using func $comp_func"
        eval "$comp_func $cmd $cur $prev" 2>/dev/null

    elif [ "$comp_cmd" != "" ]; then
        # echo "Using cmd $comp_cmd"
        eval "$comp_func $cmd $cur $prev" 2>/dev/null
    else
        compgen_args=$(printf "%s" "$complete_p" | cut -d' ' -f2-)
        # echo "Using compgen $compgen_args"
        compgen $compgen_args
    fi
}

# Detect if this is macOS
macos=$(echo $OSTYPE | sed -e '1s/^darwin.*$/yes/')

system_completion=/usr/share/bash-completion/bash_completion
[ $macos = "yes" ] && system_completion=$(brew --prefix)/etc/bash_completion

deduce_function=false
source_system_completion=true
source_file=""
wordbreaks=""
dbglog=""
[[ "$1" == -* ]] && while true; do
    case $1 in
        -w|--wordbreaks)
            # sets wordbreaks
            if [[ "$2" == -* ]]; then
                echo "ERR: Invalid value <$2> for -w|--wordbreaks option" >&2
                print_help
                exit 2
            fi
            wordbreaks="$2"
            shift   
            ;;
        -s|--source)
            # sets source_file
            if [[ "$2" == -* ]]; then
                echo "ERR: Invalid value <$2> for -s|--source option" >&2
                print_help
                exit 2
            fi
            source_file="$2"
            shift   
            ;;
        -F|--deduce-function)
            # sets deduce_function to true
            deduce_function=true
            ;;
        -S|--no-system-completion)
            # dont source system completion 
            source_system_completion=false
            ;;
        -d|--debug)
            # sets debugging/logging file
            if [[ "$2" == -* ]]; then
                echo "ERR: Invalid value <$2> for -d|--debug option" >&2
                print_help
                exit 2
            fi
            dbglog="$2"
            shift   
            ;;
        -h|--help)
            print_help
            exit 0
            ;;
        --)
            # ends option processing
            # next argument is positional
            shift
            break   
            ;;
        -*)
            echo "ERR: Invalid option <$1>" >&2
            print_help
            exit 1
            ;;
        *)
            # no more options
            # this argument is positional
            break   
            ;;
    esac
    shift
done

fake_arg=0
[ "$deduce_function" != false ] && fake_arg=1

arg_count=$((4 - fake_arg))
if [ $# -lt $arg_count ]; then
    echo "ERR: Not enough positional arguments <$#>" >&2
    echo "Commandline <$@>" >&2
    print_help
    exit 3
fi

if [ "$source_system_completion" == "true" ]; then
    # source system bash_completion
    source "$system_completion"
fi

if [ "$source_file" != "" ]; then
    # source custom file
    source "$source_file"
fi

if [ "$deduce_function" == false ]; then 
    comp_func=$1
    shift
else
    #get_comp_func

    # get first word
    complete_cmd=$(echo "$3" | cut -d' ' -f1)
    if [ "$complete_cmd" == "" ]; then
        complete_cmd="-E"
        echo "WARN: Completion detection for empty line is currently in BETA!" >&2 
        #print_help
        #exit 4
    fi
    # get registered completion for command
    if ! complete_p=$(complete -p "$complete_cmd" 2>/dev/null); then
        echo "run default"
        if ! complete_p=$(complete -p -D 2>/dev/null); then
            echo "no default completion: complete -D" 
            exit 88 
        fi
        parse_complete_p 
        do_complete

        if ! complete_p=$(complete -p "$complete_cmd" 2>/dev/null); then
            echo "no compspec matching provided command" 
            exit 99 
        fi

    fi
    parse_complete_p

fi

COMP_CWORD=$1
COMP_POINT=$2
COMP_WORDS=($3)
COMP_LINE=$3

# default: "!" (listing alternatives on partial word completion)
COMP_TYPE=33
# if specified as argument
[ $# -ge 4 ] && COMP_TYPE=$4

# default: TAB
COMP_KEY=9
# if specified as argument
[ $# -ge 5 ] && COMP_KEY=$5

# arguments
cmd=${COMP_WORDS[0]}
cur=${COMP_WORDS[COMP_CWORD]}
prev=${COMP_WORDS[COMP_CWORD-1]}

[ "$wordbreaks" != "" ] && COMP_WORDBREAKS="$wordbreaks"

if [ "$dbglog" != "" ]; then
    echo "### bash-complete-api called at [$(date +\"%Y-%m-%d_%H:%M:%S\")] ###" >> "$dbglog"
    echo "comp_func: $comp_func" >> "$dbglog"
    echo "COMP_CWORD: $COMP_CWORD" >> "$dbglog"
    echo "COMP_POINT: $COMP_POINT" >> "$dbglog"
    echo "COMP_WORDS[0]: ${COMP_WORDS[0]}" >> "$dbglog"
    echo "COMP_WORDS[@]: ${COMP_WORDS[@]}" >> "$dbglog"
    echo "COMP_LINE: $COMP_LINE" >> "$dbglog"
    echo "COMP_WORDBREAKS: $COMP_WORDBREAKS" >> "$dbglog"
    echo "COMP_TYPE: $COMP_TYPE" >> "$dbglog"
    echo "COMP_KEY: $COMP_KEY" >> "$dbglog"
    echo "###" >> "$dbglog"
    echo " " >> "$dbglog"
fi

# sometimes bash notices out that there is no actual completion running
#    and produces some errors - we throw them away via 2>/dev/null
do_complete
print_completions
